name: deploy-reactorcide-vm
image: containers.catalystsquad.com/public/reactorcide/runnerbase:dev
command: |-
    set -euo pipefail

    echo "========================================"
    echo "Reactorcide VM Deployment"
    echo "========================================"
    echo "Target: ${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}"
    echo "Domains: ${REACTORCIDE_DEPLOY_DOMAINS}"
    echo ""

    # Setup SSH from environment variable
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh

    if [ -z "${SSH_PRIVATE_KEY:-}" ]; then
      echo "ERROR: SSH_PRIVATE_KEY environment variable not set"
      exit 1
    fi

    echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
    chmod 600 ~/.ssh/id_rsa
    echo "SSH key configured"

    # Add host to known_hosts to avoid prompt
    ssh-keyscan -H "${REACTORCIDE_DEPLOY_HOST}" >> ~/.ssh/known_hosts 2>/dev/null || true

    # Test SSH connection
    echo "Testing SSH connection..."
    if ! ssh -o ConnectTimeout=10 "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" "echo SSH OK"; then
      echo "ERROR: SSH connection failed"
      exit 1
    fi

    # Generate secrets if not provided
    DB_PASSWORD="${REACTORCIDE_DB_PASSWORD:-$(openssl rand -hex 24)}"
    JWT_SECRET="${REACTORCIDE_JWT_SECRET:-$(openssl rand -hex 32)}"
    REMOTE_DIR="${REACTORCIDE_REMOTE_DIR:-~/reactorcide}"

    echo ""
    echo "Step 1: Creating remote directory structure"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" "mkdir -p ${REMOTE_DIR}"

    echo ""
    echo "Step 2: Detecting and configuring container runtime"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" bash -s <<'REMOTE_EOF'
    set -euo pipefail
    cd ~/reactorcide

    # Detect container runtime and socket
    CONTAINER_RUNTIME=""
    CONTAINER_SOCKET=""
    DOCKER_CMD=""

    # Check for containerd first (nerdctl)
    if [ -S /run/containerd/containerd.sock ]; then
      # First check if non-root access already works
      if nerdctl ps >/dev/null 2>&1; then
        CONTAINER_RUNTIME="containerd"
        CONTAINER_SOCKET="/run/containerd/containerd.sock"
        DOCKER_CMD="nerdctl"
        echo "Detected: containerd with nerdctl (no sudo needed)"
      elif sudo nerdctl ps >/dev/null 2>&1; then
        CONTAINER_RUNTIME="containerd"
        CONTAINER_SOCKET="/run/containerd/containerd.sock"
        echo "Detected: containerd with nerdctl (checking socket permissions...)"

        # Check actual socket group ownership (GID 996 = containerd group)
        SOCKET_GID=$(stat -c %g /run/containerd/containerd.sock 2>/dev/null || echo "0")
        if [ "$SOCKET_GID" = "996" ]; then
          echo "Socket already has correct group (gid=996), user may need re-login for group membership"
          DOCKER_CMD="sudo nerdctl"
        else
          echo "Configuring containerd socket for non-root access (current gid=$SOCKET_GID)..."

          # Create containerd group (GID 996 matches docker group convention)
          sudo groupadd -g 996 containerd 2>/dev/null || true

          # Update containerd config with socket group permissions
          sudo mkdir -p /etc/containerd
          sudo tee /etc/containerd/config.toml > /dev/null <<'CONTAINERD_CONFIG'
    version = 2

    [grpc]
    address = "/run/containerd/containerd.sock"
    uid = 0
    gid = 996
    CONTAINERD_CONFIG

          sudo sed -i 's/^    //' /etc/containerd/config.toml

          echo "Restarting containerd to apply socket permissions..."
          sudo systemctl restart containerd
          sleep 2

          # Check if it worked
          if nerdctl ps >/dev/null 2>&1; then
            DOCKER_CMD="nerdctl"
            echo "Socket permissions configured successfully"
          else
            DOCKER_CMD="sudo nerdctl"
            echo "Using sudo nerdctl (group membership requires re-login)"
          fi
        fi
      fi
    fi

    # Fall back to Docker if containerd not available
    if [ -z "$CONTAINER_RUNTIME" ]; then
      if [ -S /var/run/docker.sock ]; then
        if docker ps >/dev/null 2>&1; then
          CONTAINER_RUNTIME="docker"
          CONTAINER_SOCKET="/var/run/docker.sock"
          DOCKER_CMD="docker"
          echo "Detected: Docker (no sudo)"
        elif sudo docker ps >/dev/null 2>&1; then
          CONTAINER_RUNTIME="docker"
          CONTAINER_SOCKET="/var/run/docker.sock"
          DOCKER_CMD="sudo docker"
          echo "Detected: Docker (requires sudo)"
        fi
      fi
    fi

    if [ -z "$CONTAINER_RUNTIME" ]; then
      echo "ERROR: No container runtime found (checked containerd and docker)"
      exit 1
    fi

    # Save runtime detection results
    cat > .docker-cmd <<CMDFILE
    DOCKER_CMD="${DOCKER_CMD}"
    CONTAINER_RUNTIME="${CONTAINER_RUNTIME}"
    CONTAINER_SOCKET="${CONTAINER_SOCKET}"
    CMDFILE

    sed -i 's/^    //' .docker-cmd

    echo "Container runtime: ${CONTAINER_RUNTIME}"
    echo "Socket: ${CONTAINER_SOCKET}"
    REMOTE_EOF

    echo ""
    echo "Step 3: Copying deployment files"
    tar -C /job/deployment -czf - docker-compose.prod.yml nginx.conf | ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" "tar -C ${REMOTE_DIR} -xzf -"

    echo ""
    echo "Step 4: Checking environment configuration on VM"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" bash -s <<'REMOTE_EOF'
    set -euo pipefail
    cd ~/reactorcide
    source .docker-cmd

    if [ -f .env ]; then
      echo "Existing .env found - preserving configuration"
      echo "Current config (passwords masked):"
      grep -v PASSWORD .env | grep -v SECRET | grep -v URI || true

      # Update container runtime if it changed
      if grep -q "^REACTORCIDE_CONTAINER_RUNTIME=" .env; then
        sed -i "s|^REACTORCIDE_CONTAINER_RUNTIME=.*|REACTORCIDE_CONTAINER_RUNTIME=${CONTAINER_RUNTIME}|" .env
      else
        echo "REACTORCIDE_CONTAINER_RUNTIME=${CONTAINER_RUNTIME}" >> .env
      fi
      echo "Updated REACTORCIDE_CONTAINER_RUNTIME=${CONTAINER_RUNTIME}"
    else
      echo "No existing .env found - creating new configuration"
      DB_PASSWORD=$(openssl rand -hex 24)
      JWT_SECRET=$(openssl rand -hex 32)

      cat > .env <<ENVFILE
    # Database Configuration (for postgres containers)
    POSTGRES_USER=reactorcide
    POSTGRES_PASSWORD=${DB_PASSWORD}
    POSTGRES_DB=reactorcide_db
    CORNDOGS_DB_NAME=corndogs_db

    # Reactorcide Configuration
    REACTORCIDE_DB_URI=postgresql://reactorcide:${DB_PASSWORD}@postgres:5432/reactorcide_db?sslmode=disable
    REACTORCIDE_JWT_SECRET=${JWT_SECRET}

    # Object Storage Configuration
    # WARNING: Job logs are stored here. The 'filesystem' type stores logs in a Docker volume.
    # If you remove the reactorcide_data volume, all job logs will be lost.
    # For production deployments, consider using S3/GCS object storage instead.
    # Options: filesystem, s3, gcs
    REACTORCIDE_OBJECT_STORE_TYPE=filesystem
    REACTORCIDE_OBJECT_STORE_BASE_PATH=/data/reactorcide

    # Worker Configuration
    REACTORCIDE_WORKER_CONCURRENCY=2
    REACTORCIDE_WORKER_POLL_INTERVAL=5
    REACTORCIDE_CONTAINER_RUNTIME=${CONTAINER_RUNTIME}
    REACTORCIDE_LOG_LEVEL=info
    ENVFILE

      # Remove leading whitespace from .env file
      sed -i 's/^    //' .env

      echo "Environment configuration created"
    fi

    # Generate compose override for container socket mount and runtime-specific volumes
    echo "Generating compose override for ${CONTAINER_RUNTIME}..."
    if [ "${CONTAINER_RUNTIME}" = "containerd" ]; then
      # Find nerdctl binary path
      NERDCTL_PATH=$(which nerdctl 2>/dev/null || echo "/usr/local/bin/nerdctl")
      if [ ! -f "$NERDCTL_PATH" ]; then
        NERDCTL_PATH="/usr/bin/nerdctl"
      fi
      echo "Using nerdctl at: $NERDCTL_PATH"

      # Create nerdctl data directory if it doesn't exist
      sudo mkdir -p /var/lib/nerdctl

      # Containerd/nerdctl needs these mounts:
      # - /run/containerd for socket and FIFO pipes
      # - /var/lib/containerd for snapshotter data (image layers)
      # - /var/lib/nerdctl for nerdctl state (container metadata, names, etc.)
      # - /etc/containerd for containerd config and registry certs
      # - /opt/cni/bin for CNI plugin binaries
      # - /etc/cni/net.d for CNI network configuration
      # - nerdctl binary (needed by OCI runtime shim for logging)
      printf 'services:\n  worker:\n    volumes:\n      - /run/containerd:/run/containerd\n      - /var/lib/containerd:/var/lib/containerd\n      - /var/lib/nerdctl:/var/lib/nerdctl\n      - /etc/containerd:/etc/containerd:ro\n      - /opt/cni/bin:/opt/cni/bin:ro\n      - /etc/cni/net.d:/etc/cni/net.d:ro\n      - %s:/usr/local/bin/nerdctl:ro\n' "$NERDCTL_PATH" > docker-compose.override.yml
    else
      # Docker only needs the socket
      printf 'services:\n  worker:\n    volumes:\n      - %s:%s\n' "${CONTAINER_SOCKET}" "${CONTAINER_SOCKET}" > docker-compose.override.yml
    fi
    echo "Created docker-compose.override.yml for ${CONTAINER_RUNTIME}"
    REMOTE_EOF

    echo ""
    echo "Step 5: Updating image configuration"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" bash -s <<REMOTE_EOF
    set -euo pipefail
    cd ~/reactorcide

    # Update image configuration in .env (add or replace)
    update_env_var() {
      local key="\$1"
      local value="\$2"
      if [ -n "\$value" ]; then
        if grep -q "^\${key}=" .env 2>/dev/null; then
          sed -i "s|^\${key}=.*|\${key}=\${value}|" .env
        else
          echo "\${key}=\${value}" >> .env
        fi
        echo "  \${key}=\${value}"
      fi
    }

    echo "Configuring container images:"
    update_env_var "REACTORCIDE_COORDINATOR_IMAGE" "${REACTORCIDE_COORDINATOR_IMAGE:-}"
    update_env_var "REACTORCIDE_WORKER_IMAGE" "${REACTORCIDE_WORKER_IMAGE:-}"
    update_env_var "REACTORCIDE_RUNNER_IMAGE" "${REACTORCIDE_RUNNER_IMAGE:-}"
    REMOTE_EOF

    echo ""
    echo "Step 6: Pulling Docker images on VM"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" bash -s <<'REMOTE_EOF'
    set -euo pipefail
    cd ~/reactorcide
    source .docker-cmd
    source .env

    # Pull all Reactorcide images from registry
    echo "Pulling coordinator image..."
    $DOCKER_CMD compose -f docker-compose.prod.yml -f docker-compose.override.yml pull coordinator-api

    echo "Pulling worker image..."
    $DOCKER_CMD compose -f docker-compose.prod.yml -f docker-compose.override.yml pull worker

    # Pull runner image (used by worker to spawn job containers)
    RUNNER_IMAGE="${REACTORCIDE_RUNNER_IMAGE:-containers.catalystsquad.com/public/reactorcide/runnerbase:dev}"
    echo "Pulling runner image: ${RUNNER_IMAGE}..."
    $DOCKER_CMD pull "${RUNNER_IMAGE}"

    # Tag as local name for worker to use
    $DOCKER_CMD tag "${RUNNER_IMAGE}" reactorcide/runner:latest

    echo "Images ready"
    REMOTE_EOF

    echo ""
    echo "Step 7: Starting services"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" bash -s <<'REMOTE_EOF'
    set -euo pipefail
    cd ~/reactorcide
    source .docker-cmd

    # Stop existing services
    echo "Stopping existing services..."
    $DOCKER_CMD compose -f docker-compose.prod.yml -f docker-compose.override.yml down || true

    # Start services
    echo "Starting services..."
    $DOCKER_CMD compose -f docker-compose.prod.yml -f docker-compose.override.yml up -d

    # Wait for startup
    sleep 10

    # Show status
    $DOCKER_CMD compose -f docker-compose.prod.yml -f docker-compose.override.yml ps
    REMOTE_EOF

    echo ""
    echo "Step 8: Waiting for postgres to be healthy"
    for i in $(seq 1 30); do
      if ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" "source ~/reactorcide/.docker-cmd && \$DOCKER_CMD exec reactorcide-postgres pg_isready -U reactorcide" > /dev/null 2>&1; then
        echo "Postgres is ready"
        break
      fi
      echo "Waiting for postgres... ($i/30)"
      sleep 2
    done

    echo ""
    echo "Step 9: Running database migrations"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" "source ~/reactorcide/.docker-cmd && \$DOCKER_CMD exec reactorcide-coordinator /reactorcide migrate"

    echo ""
    echo "Step 10: Restarting coordinator to pick up migrations"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" bash -s <<'REMOTE_EOF'
    set -euo pipefail
    cd ~/reactorcide
    source .docker-cmd
    $DOCKER_CMD compose -f docker-compose.prod.yml -f docker-compose.override.yml restart coordinator-api
    REMOTE_EOF

    echo ""
    echo "Step 11: Waiting for coordinator to be healthy"
    for i in $(seq 1 30); do
      if ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" "curl -sf http://localhost:6080/api/v1/health" > /dev/null 2>&1; then
        echo "Coordinator is healthy"
        break
      fi
      echo "Waiting... ($i/30)"
      sleep 2
    done

    echo ""
    echo "Step 12: Verifying database and users"
    USER_COUNT=$(ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" \
      "source ~/reactorcide/.docker-cmd && \$DOCKER_CMD exec reactorcide-postgres psql -U reactorcide -d reactorcide_db -t -c 'SELECT COUNT(*) FROM users;'" | tr -d ' ')
    if [ "$USER_COUNT" -gt 0 ]; then
      echo "Users exist in database (found $USER_COUNT user(s))"
    else
      echo "ERROR: No users found in database"
      exit 1
    fi

    echo ""
    echo "Step 13: Final verification"
    ssh "${REACTORCIDE_DEPLOY_USER}@${REACTORCIDE_DEPLOY_HOST}" bash -s <<'REMOTE_EOF'
    set -euo pipefail
    cd ~/reactorcide
    source .docker-cmd

    if curl -sf http://localhost:6080/api/v1/health > /dev/null; then
      echo "Coordinator API is healthy"
    else
      echo "API health check failed"
      exit 1
    fi

    # Show running services
    echo ""
    echo "Running services:"
    $DOCKER_CMD compose -f docker-compose.prod.yml -f docker-compose.override.yml ps
    REMOTE_EOF

    echo ""
    echo "========================================"
    echo "Deployment completed successfully!"
    echo "========================================"
    echo ""
    echo "Access the API: http://${REACTORCIDE_DEPLOY_HOST}:6080/api/v1/health"
environment:
    # Required - target configuration
    REACTORCIDE_DEPLOY_HOST: "${env:REACTORCIDE_DEPLOY_HOST}"
    REACTORCIDE_DEPLOY_USER: "${env:REACTORCIDE_DEPLOY_USER}"
    REACTORCIDE_DEPLOY_DOMAINS: "${env:REACTORCIDE_DEPLOY_DOMAINS}"

    # Required - SSH key for deployment (secret)
    SSH_PRIVATE_KEY: "${secret:reactorcide/deploy:ssh_private_key}"

    # Optional - can use secrets or generate at runtime
    REACTORCIDE_DB_PASSWORD: "${secret:reactorcide/deploy:db_password}"
    REACTORCIDE_JWT_SECRET: "${secret:reactorcide/deploy:jwt_secret}"

    # Optional with defaults
    REACTORCIDE_WORKER_CONCURRENCY: "${env:REACTORCIDE_WORKER_CONCURRENCY}"
    REACTORCIDE_WORKER_POLL_INTERVAL: "${env:REACTORCIDE_WORKER_POLL_INTERVAL}"
    REACTORCIDE_LOG_LEVEL: "${env:REACTORCIDE_LOG_LEVEL}"
    REACTORCIDE_REMOTE_DIR: "${env:REACTORCIDE_REMOTE_DIR}"

    # Container image overrides (for internal registries)
    REACTORCIDE_COORDINATOR_IMAGE: "${env:REACTORCIDE_COORDINATOR_IMAGE}"
    REACTORCIDE_WORKER_IMAGE: "${env:REACTORCIDE_WORKER_IMAGE}"
    REACTORCIDE_RUNNER_IMAGE: "${env:REACTORCIDE_RUNNER_IMAGE}"
